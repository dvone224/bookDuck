<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>새 그룹 생성</title>
    <style>
        body { font-family: sans-serif; }
        .form-container { max-width: 600px; margin: 20px auto; padding: 20px; border: 1px solid #ccc; border-radius: 8px; }
        .form-group { margin-bottom: 15px; /* 그룹 간 간격 조정 */ }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="search"] { width: calc(100% - 18px); /* padding 고려 */ padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem;}
        input:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25); }

        /* --- 에러 메시지 스타일 --- */
        .error-message {
            color: red;
            font-size: 0.875em; /* 14px */
            margin-top: 4px; /* 인풋 바로 아래 */
            min-height: 1.2em; /* 메시지 없을 때 공간 확보 */
            display: block; /* 항상 블록 요소로 */
        }
        /* --- 검색 결과 스타일 --- */
        #search-results-container {
            position: relative; /* 내부 절대 위치 요소 기준점 */
        }
        #searchResults {
            position: absolute;
            width: calc(100% - 2px); /* 테두리 고려 */
            border: 1px solid #ccc;
            border-top: none;
            max-height: 150px;
            overflow-y: auto;
            background-color: white;
            list-style: none;
            padding: 0;
            margin: -1px 0 0 0; /* 입력 필드 바로 아래 붙도록 */
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: none; /* 기본 숨김 */
            border-bottom-left-radius: 4px;
            border-bottom-right-radius: 4px;
        }
        #searchResults li {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 0.95em;
        }
        #searchResults li:last-child {
            border-bottom: none;
        }
        #searchResults li:hover {
            background-color: #f0f0f0;
        }
        #searchResults li.no-results { /* 검색 결과 없을 때 스타일 */
            cursor: default;
            color: #777;
        }

        /* --- 선택된 사용자 스타일 --- */
        #selectedUsersContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px;
            border: 1px solid #eee;
            min-height: 40px; /* 최소 높이 */
            border-radius: 4px;
            margin-top: 5px;
            background-color: #f9f9f9;
        }
        .selected-user-tag {
            display: inline-flex;
            align-items: center;
            background-color: #e0e0e0;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.875em; /* 14px */
        }
        .selected-user-tag .user-nickname {
            margin-right: 6px;
        }
        .selected-user-tag .remove-user {
            display: flex; /* X 중앙 정렬 */
            align-items: center; /* X 중앙 정렬 */
            justify-content: center; /* X 중앙 정렬 */
            width: 16px;
            height: 16px;
            cursor: pointer;
            font-weight: bold;
            color: #555;
            border: none;
            background-color: #c0c0c0; /* 약간 다른 배경색 */
            border-radius: 50%; /* 원형 버튼 */
            padding: 0;
            font-size: 12px; /* X 크기 */
            line-height: 1; /* 라인 높이 조정 */
            margin-left: 4px; /* 닉네임과의 간격 */
            transition: background-color 0.2s, color 0.2s;
        }
        .selected-user-tag .remove-user:hover {
            background-color: #a0a0a0;
            color: #fff;
        }

        /* --- 버튼 --- */
        .action-buttons { text-align: center; margin-top: 25px; }
        button[type="submit"] {
            padding: 10px 25px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1rem; /* 16px */
            transition: background-color 0.2s;
        }
        button[type="submit"]:hover:not(:disabled) {
            background-color: #0056b3;
        }
        button[type="submit"]:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.7;
        }
    </style>
</head>
<body>

<div class="form-container">
    <h1>새 그룹 생성</h1>

    <!-- 그룹 생성 요청을 처리할 서버의 URL -->
    <form id="createGroupForm" th:action="@{/group/create}" method="post">

        <!-- 1. 그룹 이름 입력 -->
        <div class="form-group">
            <label for="groupNameInput">그룹 이름:</label>
            <input type="text" id="groupNameInput" name="groupName" placeholder="그룹 이름을 입력하세요" required autocomplete="off">
            <!-- 그룹 이름 중복/유효성 에러 메시지 영역 -->
            <span id="groupNameError" class="error-message"></span>
        </div>

        <!-- 2. 사용자 검색 및 선택 -->
        <div class="form-group">
            <!-- 서버 측에서 설정한 멤버 수 제한에 맞춰 레이블 수정 (예: 본인 제외 1~3명 -> 총 2~4명) -->
            <label for="userSearchInput">멤버 추가 (본인 제외 1명 ~ 3명):</label>
            <div id="search-results-container">
                <input type="search" id="userSearchInput" placeholder="초대할 사용자 닉네임 검색 (예: 오리)" autocomplete="off">
                <!-- 검색 결과가 표시될 리스트 -->
                <ul id="searchResults"></ul>
            </div>
        </div>

        <!-- 3. 선택된 사용자 목록 표시 -->
        <div class="form-group">
            <label>선택된 멤버:</label>
            <div id="selectedUsersContainer">
                <!-- 선택된 사용자가 여기에 태그 형태로 추가됨 -->
                <!-- 예: <span class="selected-user-tag" data-user-id="123"><span class="user-nickname">닉네임</span><button class="remove-user" type="button" data-user-id="123">×</button></span> -->
            </div>
            <!-- 실제 form 제출 시 사용될 숨겨진 input 필드들을 담을 곳 -->
            <div id="hiddenMemberIdsContainer" style="display: none;">
                <!-- 예: <input type="hidden" name="memberIds" value="123" id="hidden-user-123"> -->
            </div>
        </div>

        <!-- 4. 멤버 수 관련 에러 메시지 표시 영역 -->
        <div class="form-group"> <!-- 에러 메시지도 form-group으로 감싸 간격 유지 -->
            <span id="memberErrorMessage" class="error-message"></span>
        </div>

        <!-- 5. 그룹 생성 버튼 -->
        <div class="action-buttons">
            <button type="submit" id="submitButton" disabled>그룹 생성</button>
            <!-- 초기에는 비활성화 -->
        </div>

    </form>
</div>

<script>
    // --- 요소 가져오기 ---
    const searchInput = document.getElementById('userSearchInput');
    const searchResults = document.getElementById('searchResults');
    const selectedUsersContainer = document.getElementById('selectedUsersContainer');
    const hiddenMemberIdsContainer = document.getElementById('hiddenMemberIdsContainer');
    const groupNameInput = document.getElementById('groupNameInput');
    const groupNameError = document.getElementById('groupNameError'); // 그룹 이름 에러 메시지 요소
    const createGroupForm = document.getElementById('createGroupForm');
    const submitButton = document.getElementById('submitButton');
    const memberErrorMessageDiv = document.getElementById('memberErrorMessage'); // 멤버 관련 에러 메시지 요소

    // --- 상태 변수 ---
    let selectedUsers = new Map(); // 선택된 사용자 관리 (ID -> NickName)
    // *** 중요: 이 값은 백엔드 GroupController의 유효성 검사 로직과 일치해야 합니다. ***
    const MIN_SELECTED_MEMBERS = 1; // 그룹장(본인)을 제외하고 선택해야 하는 최소 멤버 수
    const MAX_SELECTED_MEMBERS = 3; // 그룹장(본인)을 제외하고 선택해야 하는 최대 멤버 수
    let isGroupNameAvailable = false; // 그룹 이름 사용 가능 여부 (중복 체크 결과)
    let isCheckingGroupName = false;  // 그룹 이름 확인 중 상태 플래그
    let groupNameCheckTimeout; // 그룹 이름 중복 체크 디바운싱 타이머
    let userSearchTimeout; // 사용자 검색 디바운싱 타이머

    // --- 백엔드 엔드포인트 (실제 환경에 맞게 설정) ---
    const USER_SEARCH_URL = '/user/search';           // 사용자 검색 API 경로 (백엔드 컨트롤러 확인 필요)
    const GROUP_NAME_CHECK_URL = '/group/check-name'; // 그룹 이름 중복 확인 API 경로
    // 폼의 action 속성에 이미 설정되어 있지만, 필요시 JS에서도 사용 가능
    const CREATE_GROUP_URL = '/group/create';        // 그룹 생성 API 경로 (폼 action과 동일해야 함)

    // --- 이벤트 리스너 ---

    // 1. 그룹 이름 입력 시 (디바운싱 적용된 중복 확인)
    groupNameInput.addEventListener('input', () => {
        clearTimeout(groupNameCheckTimeout);
        const groupName = groupNameInput.value.trim();

        // 입력 시작 시, 이전 중복 상태 무효화 및 에러 메시지 초기화
        isGroupNameAvailable = false;
        groupNameError.textContent = ''; // 이전 에러 메시지 즉시 제거
        isCheckingGroupName = false; // 확인 중 상태 초기화

        if (groupName.length > 0) {
            // 입력 중임을 시각적으로 표시 (선택 사항)
            // groupNameInput.style.borderColor = '#ffc107'; // 예: 노란색 테두리
            groupNameError.textContent = '확인 중...'; // 메시지로 확인 중 표시
            groupNameError.style.color = '#777'; // 확인 중 메시지 색상
            isCheckingGroupName = true; // 확인 시작 플래그
            validateForm(); // 버튼 상태 업데이트 (확인 전이므로 보통 비활성화)

            groupNameCheckTimeout = setTimeout(() => {
                checkGroupNameAvailability(groupName);
            }, 500); // 500ms 후에 중복 체크 실행
        } else {
            // 입력값이 없으면 에러 메시지 지우고, 확인 중 상태 해제
            // groupNameInput.style.borderColor = ''; // 테두리 색상 원래대로
            groupNameError.textContent = ''; // 빈 이름 에러는 required 속성 또는 validateForm에서 처리
            validateForm(); // 버튼 상태 업데이트
        }
    });

    // 2. 검색어 입력 시 (사용자 검색, 디바운싱)
    searchInput.addEventListener('input', () => {
        clearTimeout(userSearchTimeout);
        const query = searchInput.value.trim();
        searchResults.style.display = 'none'; // 입력 시작 시 이전 결과 숨김

        if (query.length > 0) {
            // TODO: 검색 중 로딩 표시 추가 가능 (예: '검색 중...' li 항목)
            userSearchTimeout = setTimeout(() => {
                fetchUsers(query);
            }, 300); // 300ms 후에 검색 실행
        } else {
            clearSearchResults(); // 입력 없으면 결과창 완전히 제거
        }
    });

    // 3. 검색 결과 클릭 시 사용자 선택
    searchResults.addEventListener('click', (event) => {
        const targetLi = event.target.closest('li'); // li 또는 내부 요소 클릭 시 li 찾기
        if (targetLi && targetLi.dataset.userId) {
            const userId = targetLi.dataset.userId;
            const userNickname = targetLi.dataset.userNickname;

            // 이미 선택되었는지 확인
            if (selectedUsers.has(userId)) {
                showMemberError('이미 선택된 사용자입니다.');
                searchInput.focus(); // 다시 검색할 수 있도록 포커스
                return;
            }
            // 최대 인원 확인
            if (selectedUsers.size >= MAX_SELECTED_MEMBERS) {
                showMemberError(`멤버는 본인 제외 최대 ${MAX_SELECTED_MEMBERS}명까지만 추가할 수 있습니다.`);
                searchInput.value = ''; // 입력값 비우기
                clearSearchResults(); // 결과창 닫기
                return;
            }

            // 사용자 추가
            addSelectedUser(userId, userNickname);

            // 추가 후 정리
            searchInput.value = ''; // 검색창 비우기
            clearSearchResults(); // 검색 결과 숨기기
            searchInput.focus(); // 다음 사용자 검색 용이하게 포커스
            validateForm(); // 멤버 수 변경되었으므로 유효성 검사 및 버튼 상태 업데이트
        }
    });

    // 4. 선택된 사용자 제거 버튼 클릭 시
    selectedUsersContainer.addEventListener('click', (event) => {
        if (event.target.classList.contains('remove-user')) {
            const userId = event.target.dataset.userId;
            removeSelectedUser(userId);
            validateForm(); // 멤버 수 변경되었으므로 유효성 검사 및 버튼 상태 업데이트
        }
    });

    // 5. 폼 제출 시 최종 유효성 검사 (버튼 활성화 여부로 1차 체크)
    createGroupForm.addEventListener('submit', (event) => {
        // validateForm() 함수는 이미 버튼 활성화/비활성화를 제어함
        // 만약 버튼이 활성화된 상태에서 제출 직전 추가 검사가 필요하다면 여기서 수행
        // (예: 네트워크 상태 확인 등)

        // 현재 로직에서는 버튼 자체가 비활성화면 제출이 안 되므로, 특별한 추가 검사는 불필요해 보임
        // 만약 validateForm()이 true를 반환해도 제출을 막아야 하는 경우가 있다면 preventDefault() 사용
        if (submitButton.disabled) { // 혹시 모를 상황 대비
            event.preventDefault();
            console.warn("제출 시도됨: 버튼이 비활성화 상태입니다.");
            // 사용자에게 적절한 피드백 제공 (이미 에러 메시지가 있을 가능성 높음)
            if (!groupNameInput.value.trim()) {
                showGroupNameError("그룹 이름을 입력해주세요.");
            } else if (isCheckingGroupName) {
                showGroupNameError("그룹 이름 확인 중입니다. 잠시 후 다시 시도해주세요.");
            } else if (!isGroupNameAvailable) {
                showGroupNameError("그룹 이름이 유효하지 않거나 중복됩니다.");
            } else if (selectedUsers.size < MIN_SELECTED_MEMBERS) {
                showMemberError(`멤버를 본인 제외 ${MIN_SELECTED_MEMBERS}명 이상 선택해주세요.`);
            }
            return false; // 제출 중단
        }

        // 제출 진행 시 (버튼 활성화 상태)
        clearMemberError(); // 성공적으로 제출 시도 시 이전 에러 클리어
        clearGroupNameError();
        // 여기에 로딩 인디케이터 표시 등 추가 가능
        // 예: submitButton.textContent = '생성 중...'; submitButton.disabled = true;
    });

    // 6. 검색창/결과창 외부 클릭 시 결과 숨기기
    document.addEventListener('click', (event) => {
        const isClickInsideSearch = searchInput.contains(event.target) || searchResults.contains(event.target);
        if (!isClickInsideSearch) {
            clearSearchResults();
        }
    });

    // 7. 페이지 로드 시 초기화
    function initializeForm() {
        // 혹시 페이지 뒤로가기 등으로 인해 입력값이 남아있는 경우 처리
        if (groupNameInput.value.trim()) {
            // 페이지 로드 시에도 이름이 있으면 초기 확인 수행
            checkGroupNameAvailability(groupNameInput.value.trim());
        } else {
            validateForm(); // 빈 상태에서 초기 유효성 검사
        }
        // 선택된 사용자가 페이지 로드 시 남아있다면 (가능성은 낮음) 초기화 필요 시 로직 추가
        // selectedUsers.clear(); updateSelectedUserDisplay(); ...
    }


    // --- 함수들 ---

    // 그룹 이름 중복 확인 함수 (백엔드 API 호출)
    async function checkGroupNameAvailability(name) {
        isCheckingGroupName = true; // 확인 시작
        groupNameError.textContent = '확인 중...';
        groupNameError.style.color = '#777';
        validateForm(); // 확인 중이므로 버튼 잠시 비활성화

        try {
            const response = await fetch(`${GROUP_NAME_CHECK_URL}?name=${encodeURIComponent(name)}`);
            if (!response.ok) {
                // 4xx, 5xx 응답 처리
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json(); // 백엔드에서 { isAvailable: boolean } 형태 예상

            if (data.isAvailable) {
                isGroupNameAvailable = true;
                clearGroupNameError(); // 사용 가능하면 에러 메시지 없음
            } else {
                isGroupNameAvailable = false;
                showGroupNameError('이미 사용 중인 그룹 이름입니다.');
            }
        } catch (error) {
            console.error('Error checking group name:', error);
            isGroupNameAvailable = false; // 오류 발생 시 사용 불가능으로 간주
            showGroupNameError('이름 확인 중 오류 발생. 다시 시도해주세요.');
        } finally {
            isCheckingGroupName = false; // 확인 완료 (성공/실패 무관)
            // groupNameInput.style.borderColor = isGroupNameAvailable ? '' : 'red'; // 결과에 따라 테두리 색 변경 (선택)
            validateForm(); // 최종 유효성 검사 및 버튼 상태 업데이트
        }
    }

    // 사용자 검색 함수 (백엔드 API 호출)
    async function fetchUsers(query) {
        const searchUrl = `${USER_SEARCH_URL}?name=${encodeURIComponent(query)}&limit=8`; // 예: 최대 8개 결과 요청
        try {
            const response = await fetch(searchUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            // 백엔드에서 [{id: ..., nickName: ...}, ...] 형태의 JSON 반환 기대
            const users = await response.json();
            displaySearchResults(users);
        } catch (error) {
            console.error('Error fetching users:', error);
            // 사용자에게 피드백 줄 수 있음 (예: 검색 결과 영역에 에러 메시지 표시)
            displaySearchResults(null, '사용자 검색 중 오류 발생');
        }
    }

    // 검색 결과 표시 함수
    function displaySearchResults(users, errorMessage = null) {
        searchResults.innerHTML = ''; // 기존 결과 초기화

        if (errorMessage) {
            const li = document.createElement('li');
            li.textContent = errorMessage;
            li.classList.add('no-results'); // 스타일 적용 위해 클래스 추가
            searchResults.appendChild(li);
        } else if (users && users.length > 0) {
            let hasResultsToShow = false;
            users.forEach(user => {
                // ** 중요: 자기 자신은 검색 결과에서 제외 (백엔드에서 처리하는 것이 더 효율적) **
                // const currentUserId = getCurrentUserIdFromSomewhere(); // 현재 로그인 사용자 ID 가져오는 로직 필요
                // if (String(user.id) === String(currentUserId)) return;

                // 이미 선택된 사용자는 결과에 표시하지 않음
                if (!selectedUsers.has(String(user.id))) {
                    const li = document.createElement('li');
                    li.textContent = user.nickName; // 닉네임 표시
                    li.dataset.userId = user.id;       // data-* 속성으로 ID 저장
                    li.dataset.userNickname = user.nickName; // data-* 속성으로 닉네임 저장
                    searchResults.appendChild(li);
                    hasResultsToShow = true;
                }
            });
            // 표시할 결과가 하나도 없는 경우 (모두 이미 선택됨 등)
            if (!hasResultsToShow) {
                const li = document.createElement('li');
                li.textContent = '추가할 사용자가 없거나 이미 선택했습니다.';
                li.classList.add('no-results');
                searchResults.appendChild(li);
            }
        } else {
            // 검색 결과가 없는 경우
            const li = document.createElement('li');
            li.textContent = '검색 결과가 없습니다.';
            li.classList.add('no-results');
            searchResults.appendChild(li);
        }
        searchResults.style.display = 'block'; // 결과 리스트 표시
    }


    // 검색 결과 숨기기 함수
    function clearSearchResults() {
        searchResults.innerHTML = '';
        searchResults.style.display = 'none';
    }

    // 선택된 사용자 추가 함수 (UI 업데이트 및 숨겨진 필드 추가)
    function addSelectedUser(userId, userNickname) {
        if (!selectedUsers.has(userId) && selectedUsers.size < MAX_SELECTED_MEMBERS) {
            selectedUsers.set(userId, userNickname); // Map에 추가

            // 화면에 태그 추가
            const tag = document.createElement('span');
            tag.classList.add('selected-user-tag');
            tag.dataset.userId = userId;

            const nameSpan = document.createElement('span');
            nameSpan.classList.add('user-nickname');
            nameSpan.textContent = userNickname;

            const removeBtn = document.createElement('button');
            removeBtn.classList.add('remove-user');
            removeBtn.type = 'button'; // form 제출 방지
            removeBtn.textContent = '×'; // 'x' 문자
            removeBtn.dataset.userId = userId; // 제거 시 ID 사용
            removeBtn.setAttribute('aria-label', `${userNickname} 제거`); // 접근성

            tag.appendChild(nameSpan);
            tag.appendChild(removeBtn);
            selectedUsersContainer.appendChild(tag);

            // 숨겨진 input 추가 (폼 제출용)
            const hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.name = 'memberIds'; // 서버에서 받을 파라미터 이름
            hiddenInput.value = userId;
            hiddenInput.id = `hidden-user-${userId}`; // 제거 시 쉽게 찾기 위한 ID
            hiddenMemberIdsContainer.appendChild(hiddenInput);

            clearMemberError(); // 사용자 추가 성공 시 멤버 관련 에러 메시지 제거
        }
    }

    // 선택된 사용자 제거 함수 (UI 업데이트 및 숨겨진 필드 제거)
    function removeSelectedUser(userId) {
        if (selectedUsers.has(userId)) {
            selectedUsers.delete(userId); // Map에서 제거

            // 화면에서 태그 제거
            const tagToRemove = selectedUsersContainer.querySelector(`.selected-user-tag[data-user-id="${userId}"]`);
            if (tagToRemove) {
                selectedUsersContainer.removeChild(tagToRemove);
            }

            // 숨겨진 input 제거
            const hiddenInputToRemove = hiddenMemberIdsContainer.querySelector(`#hidden-user-${userId}`);
            if (hiddenInputToRemove) {
                hiddenMemberIdsContainer.removeChild(hiddenInputToRemove);
            }
            // 멤버 수가 변경되었으므로 에러 상태 업데이트 필요 시 여기서 호출 또는 validateForm 내에서 처리
            clearMemberError();
        }
    }

    // 폼 유효성 검사 및 버튼 상태 업데이트 함수
    function validateForm() {
        const memberCount = selectedUsers.size;
        const groupNameValue = groupNameInput.value.trim();
        const isGroupNameEntered = groupNameValue.length > 0;

        // 기본 유효성 조건
        const isMemberCountValid = memberCount >= MIN_SELECTED_MEMBERS && memberCount <= MAX_SELECTED_MEMBERS;
        const isGroupNameReady = isGroupNameEntered && !isCheckingGroupName && isGroupNameAvailable;

        // 최종 폼 유효 상태
        const isFormValid = isGroupNameReady && isMemberCountValid;

        // 버튼 상태 업데이트
        submitButton.disabled = !isFormValid;

        // 에러 메시지 업데이트 (멤버 관련)
        if (isGroupNameEntered && isGroupNameReady) { // 이름은 문제 없을 때 멤버 수 체크
            if (memberCount < MIN_SELECTED_MEMBERS) {
                showMemberError(`멤버를 본인 제외 ${MIN_SELECTED_MEMBERS}명 이상 선택해주세요.`);
            } else if (memberCount > MAX_SELECTED_MEMBERS) {
                // 이 경우는 addSelectedUser에서 미리 막히지만, 방어적으로 추가 가능
                showMemberError(`멤버는 본인 제외 최대 ${MAX_SELECTED_MEMBERS}명까지 선택 가능합니다.`);
            } else {
                clearMemberError(); // 멤버 수 조건 만족
            }
        } else {
            clearMemberError(); // 이름이 유효하지 않으면 멤버 에러는 일단 숨김 (이름 문제 해결 우선)
        }

        // 그룹 이름 관련 에러는 checkGroupNameAvailability 에서 처리됨
        // 단, 이름이 비어있을 때 메시지 처리
        if (!isGroupNameEntered && groupNameInput.hasAttribute('required')) {
            // 사용자가 입력 시도 후 지웠을 때 등 메시지 필요 시
            // showGroupNameError("그룹 이름은 필수입니다.");
        } else if (isGroupNameEntered && !isCheckingGroupName && !isGroupNameAvailable && groupNameError.textContent === '') {
            // 중복 체크 후 실패했는데 메시지가 없는 경우 (예: 초기 로드 시)
            showGroupNameError('이미 사용 중인 그룹 이름입니다.');
        }


        return isFormValid; // 현재 폼 유효 상태 반환 (submit 이벤트 등에서 사용 가능)
    }

    // 그룹 이름 관련 에러 메시지 표시
    function showGroupNameError(message) {
        groupNameError.textContent = message;
        groupNameError.style.color = 'red'; // 에러 메시지 색상
        // groupNameInput.style.borderColor = 'red'; // 입력 필드 테두리 강조 (선택)
    }

    // 그룹 이름 관련 에러 메시지 제거
    function clearGroupNameError() {
        groupNameError.textContent = '';
        // groupNameInput.style.borderColor = ''; // 테두리 복원 (선택)
    }

    // 멤버 관련 에러 메시지 표시
    function showMemberError(message) {
        memberErrorMessageDiv.textContent = message;
    }

    // 멤버 관련 에러 메시지 제거
    function clearMemberError() {
        memberErrorMessageDiv.textContent = '';
    }

    // --- 초기화 실행 ---
    initializeForm(); // 페이지 로드 시 폼 상태 초기화 및 검증

</script>

</body>
</html>